{"pageProps":{"source":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      h1: \"h1\",\n      p: \"p\",\n      a: \"a\",\n      h2: \"h2\",\n      pre: \"pre\",\n      code: \"code\",\n      h3: \"h3\",\n      h4: \"h4\",\n      em: \"em\"\n    }, _provideComponents(), props.components);\n    return _jsxs(_Fragment, {\n      children: [_jsx(_components.h1, {\n        id: \"lazyjson\",\n        children: \"Lazyjson\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Given my nature, I like to continuously improve my skills. And a great way to do that is to learn how existing things are created. That's why one day I decided, I wanted to understand parsers. It always fascinated me, how the meaning of something so complicated like a (programming) language could be parsed, and transformed into something different. For example a compiler, or an interpreter. I didn't want to create a complete programming language. That would have taken way too much time to get anything useful out of it. So I decided to try and create a JSON parser.\\nI re-wrote the parser multiple times, even in several languages. First, I used TypeScript, simply because that's what I knew best. After writing a first, rudimentary implementation, I refactored the code a couple of times, until I decided, I wanted to try out Go. So I started writing it in Go, and I recently learned about WebAssembly, so I tried compiling it to that. After a couple of issues, I left the project on the side for some time. But then I learned about another language that could be compiled into WebAssembly. Additionally, I keep hearing good things about this language, supposedly, It's even going to be inside the Linux kernel. So I chose to re-write again. This time in rust.\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"If you don't care about the details, just head over the \", _jsx(_components.a, {\n          href: \"/demos/lazyjson\",\n          children: \"interactive demo\"\n        }), \"! Otherwise, read on.\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"The parser consists of two main components, the tokenizer, and the tree builder.\"\n      }), \"\\n\", _jsx(_components.h2, {\n        id: \"tokenizer\",\n        children: \"Tokenizer\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"The tokenizer is responsible for figuring out what each part of the text is. Just simple checks, for example: \\\"Is this a number\\\", \\\"is this a comma\\\", \\\"is this whitespace\\\", and so on.\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"This step is called tokenization or often \", _jsx(_components.a, {\n          href: \"https://en.wikipedia.org/wiki/Lexical_analysis\",\n          children: \"lexical analysis\"\n        }), \".\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"I implemented each \\\"consumer\\\" in its own, separate function. A consumer in my context just takes the input, and checks if it can identify the contents, for example, here is my operator consumer:\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-rust\",\n          children: \"pub fn operator_consumer(inp: &mut CharQueue) -> Result<Option<Token>, TokenizationErr> {\\n    let c = inp.peek().ok_or(TokenizationErr::new_out_of_bounds())?;\\n\\n    let tok = match c {\\n        ':' => Token::new_json_assignment_op(inp.idx()),\\n        '=' => Token::new_equal_assignment_op(inp.idx()),\\n        _ => return Ok(None),\\n    };\\n\\n    inp.advance_by(1);\\n\\n    Ok(Some(tok))\\n}\\n\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"As you can see, well at least if you know rust a little bit, this function can return either an error or an optional token.\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Then, in the main tokenization function, all of the consumers are combined. It loops over every one of them. If a function returns a token, we can move on to the next piece of text. If it returns \", _jsx(_components.code, {\n          children: \"None\"\n        }), \", the text was not identified as consumable by this consumer, and we can check it with the next one.\"]\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-rust\",\n          children: \"pub fn tokenize(inp: &str, config: &Config) -> Result<Vec<Token>, TokenizationErr> {\\n    if inp.is_empty() {\\n        return Err(TokenizationErr::new_no_inp());\\n    }\\n\\n    let consumers: &[&Consumer] = &[\\n        &line_comment_consumer,\\n        &whitespace_consumer,\\n        &delimiter_consumer,\\n        &keyword_literal_consumer,\\n        &number_literal_consumer,\\n        &operator_consumer,\\n        &separator_consumer,\\n        &string_literal_consumer,\\n    ];\\n\\n    let mut queue = CharQueue::new(inp);\\n    let mut toks = Vec::new();\\n\\n    'o: while queue.has_remaining() {\\n        for consumer in consumers {\\n            let tok = consumer(&mut queue)?;\\n\\n            if let Some(tok) = tok {\\n                // Omit unnecessary whitespace tokens\\n                if tok.typ == TokenType::WhitespaceLiteral {\\n                    continue 'o;\\n                }\\n\\n                // Line comments are currently not supported by the treebuilder.\\n                // So if they are allowed, we omitted them, and otherwise throw an\\n                // error.\\n                if tok.typ == TokenType::LineComment {\\n                    if config.allow_line_comments {\\n                        continue 'o;\\n                    }\\n\\n                    return Err(TokenizationErr::new_line_comments_not_allowed(\\n                        tok.from, tok.to,\\n                    ));\\n                }\\n\\n                toks.push(tok);\\n                continue 'o;\\n            }\\n        }\\n\\n        panic!(\\\"{:?} was not consumed\\\", queue.peek());\\n    }\\n\\n    Ok(toks)\\n}\\n\"\n        })\n      }), \"\\n\", _jsx(_components.h2, {\n        id: \"tree-builder\",\n        children: \"Tree builder\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"After obtaining a list of tokens, the tree builder can now check for valid patterns, for example: \", _jsx(_components.code, {\n          children: \"[\"\n        }), \", \", _jsx(_components.code, {\n          children: \"false\"\n        }), \", \", _jsx(_components.code, {\n          children: \"]\"\n        }), \", and build a tree of nodes out of it. The mentioned example would result in the following node structure: \", _jsx(_components.code, {\n          children: \"ArrayNode\"\n        }), \" -> \", _jsx(_components.code, {\n          children: \"entries\"\n        }), \" -> \", _jsx(_components.code, {\n          children: \"BoolNode\"\n        }), \" -> \", _jsx(_components.code, {\n          children: \"false\"\n        }), \".\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"The tree builder works fundamentally in the same way as the tokenizer. It combines a set of consumers, and checks if they could consume a given token composition.\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-rust\",\n          children: \"pub fn number_consumer(\\n    inp: &mut Queue<Token>,\\n    _: &Rc<VarDict>,\\n    _: &Config,\\n) -> Result<Option<Node>, TreebuilderErr> {\\n    if t.typ != TokenType::NumberLiteral {\\n        return Ok(None);\\n    }\\n\\n    let i = inp.idx();\\n    let t = inp.next().unwrap();\\n\\n    Ok(Some(NumberNode::new(i, t.val.clone()).into()))\\n}\\n\"\n        })\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-rust\",\n          children: \"/// Consumes all possible forms of \\\"value constellations\\\". For example simple\\n/// numbers (`1`), or arrays (`[1, 2]`), and so on. This consumer combines other\\n/// \\\"sub-consumers\\\" to achieve this behavior.\\npub fn value_consumer(\\n    toks: &mut Peekable<TokenIndices>,\\n    var_dict: &Rc<VarDict>,\\n    config: &Config,\\n) -> Result<Option<Node>, TreebuilderErr> {\\n    let consumers: &[&Consumer] = &[\\n        &array_consumer,\\n        &keyword_consumer,\\n        &variable_usage_consumer,\\n        &number_consumer,\\n        &object_consumer,\\n        &string_consumer,\\n    ];\\n\\n    for consumer in consumers {\\n        let res = consumer(toks, var_dict, config)?;\\n\\n        if res.is_some() {\\n            return Ok(res);\\n        }\\n    }\\n\\n    Ok(None)\\n}\\n\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"So this is the basic functionality of a JSON parser complete. But I wanted to add some of my own features. Mostly \\\"fixing\\\" things I always found to be annoying about the JSON format.\"\n      }), \"\\n\", _jsx(_components.h2, {\n        id: \"trailing-commas\",\n        children: \"Trailing commas\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"The JSON format does not permit having trailing commas, this can be most annoying when moving entries around. I've also seen that another argument for trailing comma that I've read, is that to add an entry, you would need the add the entry itself, and a comma on the previous line. In source control, this will show up as a two-line change, which it isn't.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"So I went and added a config, as I wanted to be able to turn this feature on and off. And started checking for trailing commas:\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-rust\",\n          children: \"consume_val_sep(inp)?;\\n\\n// Check if the next token is an object close, if yes, we have a trailing\\n// separator.\\nif consume_obj_cls(inp, opn_i)? {\\n    if !config.allow_trailing_commas {\\n        return Err(TreebuilderErr::new_trailing_sep(inp.idx() - 2));\\n    }\\n\\n    return Ok(Some(ObjectNode::new(opn_i, inp.idx(), entries).into()));\\n}\\n\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"I also added a custom error message for it, so when the option is disabled (no trailing commas allowed), the following will appear:\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-text\",\n          children: \"expected the next value or close (trailing separator not allowed), line: 1, char: 14\\n\\n{\\\"foo\\\": \\\"bar\\\",}\\n             ^\\n\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Speaking of error messages, I spend quite a lot of time making them as useful as possible.\"\n      }), \"\\n\", _jsx(_components.h2, {\n        id: \"error-messages\",\n        children: \"Error messages\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"The parser was designed to tell the user what went wrong. For me, this was important, as I often found the error messages of the JavaScript JSON parser quite useless.\"\n      }), \"\\n\", _jsx(_components.h3, {\n        id: \"lets-look-at-a-few-error-messages\",\n        children: \"Let's look at a few error messages\"\n      }), \"\\n\", _jsxs(_components.h4, {\n        id: \"missing--inside-an-array\",\n        children: [\"Missing \", _jsx(_components.code, {\n          children: \",\"\n        }), \" inside an array\"]\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-text\",\n          children: \"expected a `,` but received a `KeywordLiteral`, line: 1, char: 8\\n\\n[false true]\\n       ^^^^\\n\"\n        })\n      }), \"\\n\", _jsx(_components.h4, {\n        id: \"missing-quotes-around-an-object-key\",\n        children: \"Missing quotes around an object key\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.em, {\n          children: \"(to be fair, this one isn't all that obvious, but still, it marks what is wrong)\"\n        })\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-text\",\n          children: \"expected a `StringLiteral` but received a `KeywordLiteral`, line: 1, char: 2\\n\\n{key: \\\"val\\\"}\\n ^^^\\n\"\n        })\n      }), \"\\n\", _jsx(_components.h4, {\n        id: \"forgot-to-close-the-object\",\n        children: \"Forgot to close the object\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-text\",\n          children: \"object was not terminated, line: 1, char: 1\\n\\n{\\\"foo\\\": \\\"bar\\\"\\n^\\n\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Next up: line comments.\"\n      }), \"\\n\", _jsx(_components.h2, {\n        id: \"line-comments\",\n        children: \"Line comments\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Provided the correct flag is set to true, the parser supports line comments. Well, the tokenizer just ignores them.\\nIf the flag is not set, the output will be:\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-text\",\n          children: \"line comments not allowed\\n\"\n        })\n      }), \"\\n\", _jsx(_components.h2, {\n        id: \"emitting\",\n        children: \"Emitting\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Given that I have a complete tree of nodes, I implemented the opposite of parsing, emitting! I've implemented this somewhat limited. The emitter is not configurable at all, but that wasn't its purpose anyway. I mainly implemented it, so that one can see some sort of output, instead of just \\\"parsed successfully\\\". Also, the next feature would be hard to demonstrate without this.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"So let's look at the maybe biggest feature I added to JSON.\"\n      }), \"\\n\", _jsx(_components.h2, {\n        id: \"variables\",\n        children: \"Variables\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Yep, I added variables. Nothing really to say about this, except that they can be defined inside container nodes (arrays, and objects), and the scope of them is bound to the node it is defined in.\\nLet's jump into some examples:\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"This is a valid variable declaration:\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-text\",\n          children: \"{let foo = 10}\\n\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"And would simply output:\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-json\",\n          children: \"{}\\n\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Actually using the variable:\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-text\",\n          children: \"{\\n    let foo = \\\"bar\\\",\\n    \\\"foobar\\\": foo\\n}\\n\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"The output:\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-json\",\n          children: \"{\\n    \\\"foobar\\\": \\\"bar\\\"\\n}\\n\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Nested variables are supported as well:\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-text\",\n          children: \"{\\n    let port = 3000,\\n    let apiArgs = [\\\"run\\\", port],\\n    let webArgs = [\\\"bind\\\", port],\\n    \\\"services\\\": {\\n        \\\"api\\\": apiArgs,\\n        \\\"web\\\": webArgs\\n    }\\n}\\n\"\n        })\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-json\",\n          children: \"{\\n    \\\"services\\\": {\\n        \\\"api\\\": [\\n            \\\"run\\\",\\n            3000\\n        ],\\n        \\\"web\\\": [\\n            \\\"bind\\\",\\n            3000\\n        ]\\n    }\\n}\\n\"\n        })\n      }), \"\\n\", _jsx(_components.h2, {\n        id: \"conclusion\",\n        children: \"Conclusion\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"This is, like all the others, a learning project, and not intended to be \", _jsx(_components.em, {\n          children: \"actually\"\n        }), \" used. There are some bugs, some errors, and definitely some improvements that could be made. But if you made it this far, definitely check out the \", _jsx(_components.a, {\n          href: \"/demos/lazyjson\",\n          children: \"demo\"\n        }), \"!\"]\n      })]\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true}