{"pageProps":{"source":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      p: \"p\",\n      strong: \"strong\",\n      h1: \"h1\",\n      pre: \"pre\",\n      code: \"code\",\n      h2: \"h2\"\n    }, _provideComponents(), props.components);\n    return _jsxs(_Fragment, {\n      children: [_jsxs(_components.p, {\n        children: [\"I wanted to display a list of all headings on my page. This is commonly known as a \\\"table of contents\\\".\\nAfter looking around online, I found an algorithm that was able to generate a TOC (\", _jsx(_components.strong, {\n          children: \"t\"\n        }), \"able \", _jsx(_components.strong, {\n          children: \"o\"\n        }), \"f \", _jsx(_components.strong, {\n          children: \"c\"\n        }), \"ontents) from a list of headings. Although only up to two levels deep. So H1s and H2s.\"]\n      }), \"\\n\", _jsx(_components.h1, {\n        id: \"old-algorithm\",\n        children: \"Old algorithm\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"I don't remember where I got the idea from, but here is the code. It's more for completeness sake anyway.\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-typescript\",\n          children: \"function generateHeadingsTreeFrom(\\n    headingElements: HTMLHeadingElement[],\\n): Heading[] {\\n    const headings: Heading[] = [];\\n\\n    for (const headingElement of headingElements) {\\n        const { innerText: text, id, nodeName } = headingElement;\\n        const heading: Heading = { children: [], id, text };\\n\\n        if (nodeName === \\\"H1\\\") {\\n            headings.push(heading);\\n        } else if (nodeName === \\\"H2\\\" && headings.length > 0) {\\n            headings[headings.length - 1].children.push(heading);\\n        }\\n    }\\n\\n    return headings;\\n}\\n\"\n        })\n      }), \"\\n\", _jsx(_components.h1, {\n        id: \"setup\",\n        children: \"Setup\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"I wanted to create an algorithm that can handle any depth. Let's go through my thought process on how to create this.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"First, this is the code I use to get my heading elements:\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-typescript\",\n          children: \"const headings = Array.from(\\n    document.querySelectorAll(\\\"h1, h2, h3, h4, h5, h6\\\"),\\n) as HTMLHeadingElement[]; // I'm using typescript btw :)\\n\\nconst tocTree = createTocTreeFrom(headings); // This is the function to implement.\\n\"\n        })\n      }), \"\\n\", _jsx(_components.h1, {\n        id: \"toctreenode\",\n        children: _jsx(_components.code, {\n          children: \"TocTreeNode\"\n        })\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Here is the \", _jsx(_components.code, {\n          children: \"TocTreeNode\"\n        }), \" definition:\"]\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-typescript\",\n          children: \"interface TocTreeNode {\\n    text: string;\\n    children: TocTreeNode[];\\n}\\n\"\n        })\n      }), \"\\n\", _jsx(_components.h1, {\n        id: \"new-any-depth-toc\",\n        children: \"New \\\"any depth\\\" toc\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-typescript\",\n          children: \"function createTocTreeFrom(headings: HTMLHeadingElement[]): TocTreeNode[] {\\n    const nodes: TocTreeNode[] = [];\\n\\n    for (const { tagName, innerText: text } of headings) {\\n        const matches = HEADING_TAG_REGEX.exec(tagName);\\n\\n        if (!matches) {\\n            continue;\\n        }\\n\\n        const headingLvl = parseInt(matches[1]);\\n\\n        if (headingLvl !== 1) {\\n            continue;\\n        }\\n\\n        nodes.push({ children: [], text });\\n    }\\n\\n    return nodes;\\n}\\n\"\n        })\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"The code above returns a simple list of all H1 elements.\\nSo let's step it up a notch. First, add an additional parameter \", _jsx(_components.code, {\n          children: \"desiredLvl\"\n        }), \",  so what we look for can be customized.\"]\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-typescript\",\n          children: \"function createTocTreeFrom(\\n    headings: HTMLHeadingElement[],\\n    desiredLvl: number,\\n): TocTreeNode[] {\\n    // ....\\n\\n    if (headingLvl !== desiredLvl) {\\n        continue;\\n    }\\n\\n    // ...\\n}\\n\"\n        })\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Let's add depth to it, by actually providing something for the \", _jsx(_components.code, {\n          children: \"children\"\n        }), \" attribute.  For now, let's just call the function recursively, but one level deeper, so \", _jsx(_components.code, {\n          children: \"desiredLvl + 1\"\n        }), \". We also want to not include previous elements, as otherwise, we would loop indefinitely.\"]\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-typescript\",\n          children: \"function createTocTreeFrom(\\n    headings: HTMLHeadingElement[],\\n    desiredLvl: number,\\n): TocTreeNode[] {\\n    const nodes: TocTreeNode[] = [];\\n\\n    for (let i = 0; i < headings.length; i++) {\\n        const { tagName, innerText: text } = headings[i];\\n        const matches = HEADING_TAG_REGEX.exec(tagName);\\n\\n        if (!matches) {\\n            continue;\\n        }\\n\\n        const headingLvl = parseInt(matches[1]);\\n\\n        if (headingLvl !== desiredLvl) {\\n            continue;\\n        }\\n\\n        const children = createTocTreeFrom(headings.slice(i + 1), desiredLvl + 1);\\n\\n        nodes.push({ children, text });\\n    }\\n\\n    return nodes;\\n}\\n\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"But this algorithm is flawed. Consider the following headings:\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-html\",\n          children: \"<h1>1</h1>\\n<h2>1.1</h2>\\n<h1>2</h1>\\n<h2>2.1</h2>\\n\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"The output would be:\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-text\",\n          children: \"- 1\\n  children:\\n    - 1.1\\n    - 2.1\\n- 2\\n  children:\\n    - 2.1\\n\"\n        })\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"As you can see, the heading \", _jsx(_components.strong, {\n          children: \"2.1\"\n        }), \" is listed under the heading \", _jsx(_components.strong, {\n          children: \"1\"\n        }), \", which is quite incorrect. This happens because we never considered the hierarchy of the headings, and just added all smaller headings to the bigger ones.\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Luckily, this is a relatively simple fix. Instead of just checking if the heading has the desired level and then adding it, we now also check if the heading is actually bigger than the current one. If it's bigger, all the next elements are of no concern to us, so we can simply return from the function.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"This final algorithm is:\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-typescript\",\n          children: \"function createTocTreeFrom(\\n    headings: HTMLHeadingElement[],\\n    desiredLvl: number,\\n): TocTreeNode[] {\\n    const nodes: TocTreeNode[] = [];\\n\\n    for (let i = 0; i < headings.length; i++) {\\n        const { tagName, innerText: text } = headings[i];\\n        const matches = HEADING_TAG_REGEX.exec(tagName);\\n\\n        if (!matches) {\\n            continue;\\n        }\\n\\n        const headingLvl = parseInt(matches[1]);\\n        const node: TocTreeNode = { children: [], text };\\n\\n        if (headingLvl < desiredLvl) {\\n            return nodes;\\n        }\\n\\n        if (headingLvl === desiredLvl) {\\n            node.children = createTocTreeFrom(headings.slice(i + 1), desiredLvl + 1);\\n            nodes.push(node);\\n        }\\n    }\\n\\n    return nodes;\\n}\\n\"\n        })\n      }), \"\\n\", _jsx(_components.h1, {\n        id: \"how-to-display-the-toc\",\n        children: \"How to display the toc\"\n      }), \"\\n\", _jsx(_components.h2, {\n        id: \"plain-javascript--typescript\",\n        children: \"Plain JavaScript / Typescript\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-typescript\",\n          children: \"function displayToc(entries: TocTreeNode[]): HTMLElement {\\n    const listElm = document.createElement(\\\"ul\\\");\\n    listElm.style.marginLeft = \\\"1em\\\";\\n\\n    for (const entry of entries) {\\n        const entryElm = document.createElement(\\\"li\\\");\\n        entryElm.append(entry.text);\\n\\n        if (entry.children.length > 0) {\\n            entryElm.appendChild(displayToc(entry.children));\\n        }\\n\\n        listElm.appendChild(entryElm);\\n    }\\n\\n    return listElm;\\n}\\n\"\n        })\n      }), \"\\n\", _jsx(_components.h2, {\n        id: \"react\",\n        children: \"React\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-tsx\",\n          children: \"function TableOfContents({ nodes }: TableOfContentsProps): ReactElement {\\n    return (\\n        <ul style={{ marginLeft: \\\"1em\\\" }}>\\n            {nodes.map((node) => (\\n                <>\\n                    <li>{node.text}</li>\\n                    {node.children && <TableOfContents nodes={node.children} />}\\n                </>\\n            ))}\\n        </ul>\\n    );\\n}\\n\"\n        })\n      })]\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true}